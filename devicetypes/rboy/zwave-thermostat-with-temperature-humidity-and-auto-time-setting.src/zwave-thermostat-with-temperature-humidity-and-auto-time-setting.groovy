/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "03.00.02"
}

/*
* This is the device type code for a z-wave customized thermostat with battery status, humidity, clock set, up-down tiles and icons.
* Base code has been take from SmartThings as of Aug 2017
*
* Thermostat with Temperature, Humidity and Auto Time setting
*
* Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
*
* Change log:
* 2017-9-25 - (v03.00.02) Added single decimal precision to show temperature reported from thermostats
* 2017-8-28 - (v03.00.01) Added the quickSetHeat and quickSetCool commands back for backwards compatibility (even thought ST made them redundant) and fix Emergency Heat
* 2017-8-26 - (v03.00.00) State change reduce duplicate logging and updated base code
* 2017-5-15 - (v02.07.01) Improved the layout to change background colors based to state of HVAC
* 2017-5-3 - (v02.07.00) Updated DTH to reflect new attributes changed by ST, added device health check and updated icons
* 2017-5-3 - (v02.06.00) Harmonized color scheme to match ST, show correct state of fan and operating, added color for Auto Fan on
* 2017-4-10 - (v2.5.4) Improved summary tile layout hvac status
* 2017-3-20 - (v2.5.4) Added CT-30 Brown Box MSR/fingerprints
* 2017-3-12 - (v2.5.3) Fix for 2.3.1 ST Android app broken UI
* 2017-2-27 - (v2.5.3) Added GoControl signature
* 2016-11-2 - Added ability to check for new code versions
* 2016-11-2 - Added Â° symbol to the temperature
* 2016-10-19 - Added more fingerprints for Ct-30 variants
* 2016-9-19 - Added more fingerprints
* 2016-9-15 - Added support for v2 style fingerprints and check for defective z-wave module for CT-XXX which shows the wrong clock and adjust for it
* 2016-8-23 - Updated battery icon
* 2016-6-25 - Added more CT-101/CT-30 fingerprints and MSR codes for CT-101/CT-30
* 2016-5-15 - Notify use if timezone/location is missing in setup
* 2016-5-4 - Added CT-30 support for identification, added support for all CT-XXX models
* 2016-4-20 - Added DH version in setup page
* 2016-4-17 - Debug discovery code
* 2016-3-29 - Added CT-101 fingerprint
* 2016-3-28 - Added CT-30 fingerprint
* 2016-3-28 - Fixed bug with Fan showing 'null' in the summary line or not showing accurate state
* 2016-3-28 - Improved reliable of configure button to program thermostat parameters
* 2016-3-28 - Added fingerprints for CT-100 and ZTS-110 for automatic setup when adding new thermostats
* 2016-3-16 - Let system set temperature units (don't force to F)
* 2016-3-15 - Added support to configure reporting threshold, swing and calibration for CT-XXX and ZTS-110 thermostats
* 2016-2-10 - Improve polling handler when skipping polling
* 2016-2-6 - Bugfix for configure throwing error
* 2016-2-6 - Fixed refresh on configuration
* 2016-2-2 - Add initialization on settings update
* 2016-1-28 - Pressing Mode and Auto no longer goes into hunting mode, only one command at a time
* 2016-1-28 - Fix for Level Up/down for Android
* 2016-1-27 - Fix for ST iOS 2.0.8 release breaking Battery UI
* 2016-1-24 - Updated base code to 2016-1-24 (emergency heat is now emergencyHeat)
* 2016-1-24 - Bugfix for error on handling invalid / empty z-wave multiInstance command
* 2016-1-2 - Temporary workaround for ? showing up on Android 2.0.7
* 2015-12-6 - ST fixed the VALUE_CONTROL issues with the iOS release 2.0.5, reenabling it
* 2015-10-23 - VALUE_CONTROL causes the new ST app to crash, so disabled this feature until ST fixes their crappy app
* 2015-9-26 - Added color palette for Humidity
* 2015-9-23 - Updated layout and colors
* 2015-9-19 - Added support for MultiAttributeTiles
* 2015-8-7 - Fix for polling stopping when in battery save mode
* 2015-7-25 - Report change in state when operating state and fan state change
* 2015-7-22 - Updated to sync with ST base code
* 2015-7-12 - Fixed issue with battery and humidity not being reported
* 2015-7-9 - Added support fot battery save mode to reduce polling frequency to 30 minutes
* 2015-6-7 - Fix for Humidity not working (thanks @schettj)
* 2015-4-24 - Fix to supporting C and F for temp up/down
* 2015-2-10 - Added capability for battery
* 2015-2-3 - Updated base code to 2015-2-3, support for thermostatFanState attribute and Emergency Heat, added sliders for temp to make faster changes
* 2015-1-1 - Fix for battery update
* 2014-11-1 - Humidity, Battery update, Auto time setting
*
*/

metadata {
    // Automatically generated. Make future change here.
    definition (name: "Z-Wave Thermostat with Temperature, Humidity and Auto Time setting", namespace: "rboy", author: "RBoy Apps") {
        capability "Actuator"
        capability "Temperature Measurement"
        capability "Relative Humidity Measurement"
        capability "Thermostat"
        capability "Configuration"
        capability "Polling"
        capability "Sensor"
        capability "Refresh"
        capability "Battery"

        attribute "thermostatFanState", "string"
        attribute "thermStatus", "string"
        attribute "fanState", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"

        command "switchMode"
        command "switchFanMode"
        command "raiseHeatingSetpoint"
        command "lowerHeatingSetpoint"
        command "raiseCoolSetpoint"
        command "lowerCoolSetpoint"
        command "levelUpDown"
        command "levelUp"
        command "levelDown"
        command "quickSetCool"
        command "quickSetHeat"

        fingerprint deviceId: "0x08"
        fingerprint inClusters: "0x43,0x40,0x44,0x31"
        fingerprint inClusters: "0x20,0x31,0x40,0x42,0x43,0x44,0x45,0x47,0x70,0x72,0x80,0x81,0x85,0x86" // ZTS-110
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x44,0x43,0x42,0x86,0x70,0x80,0x88" // CT-30
        fingerprint inClusters: "0x20,0x87,0x72,0x31,0x40,0x44,0x43,0x42,0x86,0x70,0x80,0x88" // CT-30 (rebadged model from alarm company)
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x42,0x44,0x45,0x43,0x86,0x70,0x80,0x85,0x60" // CT-100, CT-101 (Lowe's version)
        fingerprint inClusters: "0x20,0x81,0x87,0x72,0x31,0x40,0x42,0x44,0x45,0x43,0x86,0x70,0x80,0x85,0x5D,0x60" // CT-101

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"08" // Generic Thermostat
        fingerprint cc:"43,40,44,31" // Generic Thermostat
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", deviceJoinName:"CT-10X Z-Wave Thermostat" // Generic CT-100/101 Thermostat
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6401", model:"0107", deviceJoinName:"CT-100 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6401", model:"0106", deviceJoinName:"CT-100 Z-Wave Vivint Thermostat" // Vivint
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,60", mfr:"0098", prod:"6501", model:"000C", deviceJoinName:"CT-101 Z-Wave Lowes Thermostat" // Lowes
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85,5D,60", mfr:"0098", prod:"6501", model:"000C", deviceJoinName:"CT-101 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"1E10", model:"0158", deviceJoinName:"CT-30 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"0000", model:"0000", deviceJoinName:"CT-30 Rebadged Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,44,43,42,86,70,80,88", mfr:"0098", prod:"1E12", model:"015C", deviceJoinName:"CT-30e Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,31,40,42,43,44,45,47,70,72,80,81,85,86", mfr:"5254", prod:"0200", model:"8031", deviceJoinName:"ZTS-110 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,45,43,86,70,80,85", mfr:"0098", prod:"1E12", model:"015E", deviceJoinName:"CT-30 Generic Rev C1 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,81,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"001E", deviceJoinName:"APX CT-30 Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"0000", deviceJoinName:"CT-30 Brown Box Z-Wave Thermostat"
        fingerprint type:"0806", cc:"20,87,72,31,40,42,44,43,86", mfr:"0098", prod:"0001", model:"00FF", deviceJoinName:"CT-30 Brown Box Z-Wave Thermostat"
        fingerprint type:"0806", cc:"40,42,43,44,45,80,70,31,8F,86,72,85,2C,2B,73,81", mfr:"014F", prod:"5442", model:"5431", deviceJoinName:"GoControl GC-TBZ48 Z-Wave Thermostat"
        fingerprint mfr:"0039", prod:"0011", model:"0001", deviceJoinName: "Honeywell Z-Wave Thermostat" // Honeywell
    }

    preferences {
        input title: "", description: "Z-Wave Thermostat Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "batterySaveMode", "bool", title: "Save Thermostat Battery", description: "Enable this to reduce polling frequency to once in 30 minutes to save thermostat battery", required: true, displayDuringSetup: true
        input title: "", description: "This section is used to configure the CT-XXX thermostats (CT30/CT32/CT50/CT80/CT100/CT101/CT110)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "autoTempDiffCT", "enum", title: "Temperature Change Reporting Threshold", description: "Set the temperature change reporting threshold", multiple: false, defaultValue: "1.0Â°F", options: ["Disabled","0.5Â°F","1.0Â°F","1.5Â°F","2.0Â°F"], required: false, displayDuringSetup: true
        input "swingCT", "enum", title: "Temperature Swing", description: "Set the temperature swing threshold", multiple: false, defaultValue: "1.0Â°F", options: ["0.5Â°F","1.0Â°F","1.5Â°F","2.0Â°F","2.5Â°F","3.0Â°F","3.5Â°F","4.0Â°F"], required: false, displayDuringSetup: true
        input title: "", description: "This section is used to configure parameters for the ZTS-110 thermostat", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input "autoTempDiffZTS", "enum", title: "Temperature Change Reporting Threshold", description: "Set the temperature change reporting threshold", multiple: false, defaultValue: "4.0Â°F", options: ["Disabled","1.0Â°F","2.0Â°F","3.0Â°F","4.0Â°F","5.0Â°F","6.0Â°F","7.0Â°F","8.0Â°F"], required: false, displayDuringSetup: true
        input "swingZTS", "enum", title: "Temperature Swing", description: "Set the temperature swing threshold", multiple: false, defaultValue: "2.0Â°F", options: ["1.0Â°F","2.0Â°F","3.0Â°F","4.0Â°F"], required: false, displayDuringSetup: true
        input "tempCalibrationZTS", "enum", title: "Temperature Correction", description: "Set the temperature calibration", multiple: false, defaultValue: "0Â°F", options: ["-10Â°F","-9Â°F","-8Â°F","-7Â°F","-6Â°F","-5Â°F","-4Â°F","-3Â°F","-2Â°F","-1Â°F","0Â°F","1Â°F","2Â°F","3Â°F","4Â°F","5Â°F","6Â°F","7Â°F","8Â°F","9Â°F","10Â°F"], required: false, displayDuringSetup: true
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "thermostat", width: 6, height: 4){
            tileAttribute ("device.temperature", key: "PRIMARY_CONTROL") {
                attributeState("temperature", label:'${currentValue}Â°', defaultState: true)
            }
            tileAttribute ("device.thermStatus", key: "SECONDARY_CONTROL") {
                attributeState("thermStatus", label:'${currentValue}', defaultState: true)
            }
            tileAttribute ("device.level", key: "VALUE_CONTROL") {
                attributeState("default", action: "levelUpDown")
                attributeState("VALUE_UP", action: "levelUp")
                attributeState("VALUE_DOWN", action: "levelDown")
            }
            tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
                attributeState("idle", backgroundColor:"#cccccc")
                attributeState("heating", backgroundColor:"#e86d13")
                attributeState("cooling", backgroundColor:"#00A0DC")
            }
            /*tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
                attributeState("off", label:'${name}')
                attributeState("heat", label:'${name}')
                attributeState("cool", label:'${name}')
                attributeState("auto", label:'${name}')
            }
            tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
                attributeState("heatingSetpoint", label:'${currentValue}', defaultState: true)
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
                attributeState("coolingSetpoint", label:'${currentValue}', defaultState: true)
            }*/
        }
        valueTile("temperature", "device.temperature", width: 4, height: 4) {
            state("temperature", label:'${currentValue}Â°',
                  backgroundColors:[
							// Celsius
							[value: 0, color: "#153591"],
							[value: 7, color: "#1e9cbb"],
							[value: 15, color: "#90d2a7"],
							[value: 23, color: "#44b621"],
							[value: 28, color: "#f1d801"],
							[value: 35, color: "#d04e00"],
							[value: 37, color: "#bc2323"],
							// Fahrenheit
							[value: 40, color: "#153591"],
							[value: 44, color: "#1e9cbb"],
							[value: 59, color: "#90d2a7"],
							[value: 74, color: "#44b621"],
							[value: 84, color: "#f1d801"],
							[value: 95, color: "#d04e00"],
							[value: 96, color: "#bc2323"]
					]
                 )
        }
        standardTile("mode", "device.thermostatMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "off", action:"switchMode", nextState:"...", icon: "st.thermostat.heating-cooling-off"
            state "heat", action:"switchMode", nextState:"...", icon: "st.thermostat.heat", backgroundColor: '#e86d13'
            state "cool", action:"switchMode", nextState:"...", icon: "st.thermostat.cool", backgroundColor: '#00a0dc'
            state "auto", action:"switchMode", nextState:"...", icon: "st.thermostat.auto"
            state "emergency heat", action:"switchMode", nextState:"...", icon: "st.thermostat.emergency-heat", backgroundColor: '#E11102'
            state "...", label: "...", nextState:"..."
        }
        standardTile("fanMode", "device.fanState", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false, decoration: "flat") {
            state "autoOff", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-auto", defaultState: true
            state "autoOn", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-auto", backgroundColor: '#00f78c'
            state "on", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-on", backgroundColor: '#00f78c'
            state "circulate", action:"switchFanMode", nextState:"...", icon: "st.thermostat.fan-circulate", backgroundColor: '#02D2E1'
            state "...", label: "...", nextState:"..."
        }
        controlTile("heatSliderControl", "device.heatingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "heat", action:"setHeatingSetpoint", backgroundColor:"#e86d13"
        }
        standardTile("heatingSetpoint", "device.heatingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "heat", label:'${currentValue}Â°', backgroundColor: '#e86d13'
        }
        controlTile("coolSliderControl", "device.coolingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
            state "cool", action:"setCoolingSetpoint", backgroundColor: "#00a0dc"
        }
        standardTile("coolingSetpoint", "device.coolingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "cool", label:'${currentValue}Â°', backgroundColor: '#00a0dc'
        }
        standardTile("refresh", "command.refresh", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "configure", label:'', action:"configuration.configure", icon:"st.secondary.configure"
        }
        standardTile("raiseHeatingSetpoint", "device.raiseHeatingSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "raiseHeatingSetpoint", label:'Heat', action:"raiseHeatingSetpoint", icon:"st.thermostat.thermostat-up"
        }
        standardTile("lowerHeatingSetpoint", "device.lowerHeatingSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "lowerHeatingSetpoint", label:'Heat', action:"lowerHeatingSetpoint", icon:"st.thermostat.thermostat-down"
        }
        standardTile("raiseCoolSetpoint", "device.raiseCoolSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "raiseCoolSetpoint", label:'Cool', action:"raiseCoolSetpoint", icon:"st.thermostat.thermostat-up"
        }
        standardTile("lowerCoolSetpoint", "device.lowerCoolSetpoint", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "lowerCoolSetpoint", label:'Cool', action:"lowerCoolSetpoint", icon:"st.thermostat.thermostat-down"
        }
        valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'\n ${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        valueTile("humidity", "device.humidity", width: 2, height: 2, inactiveLabel: false) {
            state "humidity", label:'\n\n ${currentValue}%', icon:"st.Weather.weather12", backgroundColors: [
                [value: 20, color: "#ffe700"],
                [value: 30, color: "#d6ff00"],
                [value: 45, color: "#3cff00"],
                [value: 60, color: "#00ffb8"],
                [value: 80, color: "#00dfff"]
            ]
        }
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }

        main "summary"
        details(["summary", "mode", "fanMode", "humidity", "heatingSetpoint", "lowerHeatingSetpoint", "raiseHeatingSetpoint", "heatSliderControl", "coolingSetpoint", "lowerCoolSetpoint", "raiseCoolSetpoint", "coolSliderControl", "blank2x", "refresh", "battery"])
    }
}

def installed() {
    log.trace "Installed called"
	// Configure device
	def cmds = [new physicalgraph.device.HubAction(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:[zwaveHubNodeId]).format()),
			new physicalgraph.device.HubAction(zwave.manufacturerSpecificV2.manufacturerSpecificGet().format())]
	sendHubCommand(cmds)
	runIn(3, "initialize", [overwrite: true])  // Allow configure command to be sent and acknowledged before proceeding
}

def updated() {
    log.trace "Updated called"
	// If not set update ManufacturerSpecific data
	if (!getDataValue("manufacturer")) {
		sendHubCommand(new physicalgraph.device.HubAction(zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()))
		runIn(2, "initialize", [overwrite: true])  // Allow configure command to be sent and acknowledged before proceeding
	} else {
		initialize()
	}
}

def initialize() {
	unschedule()
	if (getDataValue("manufacturer") != "Honeywell") {
		runEvery5Minutes("poll")  // This is not necessary for Honeywell Z-wave, but could be for other Z-wave thermostats
	}
	response(configure())
}


def parse(String description) {
    def result = []
	if (description == "updated") {
	} else {
		def zwcmd = zwave.parse(description, [0x42:1, 0x43:2, 0x31:3, 0x70:2])
		if (zwcmd) {
			result << zwaveEvent(zwcmd)
            //log.debug "Parse returned $result"
		} else {
			log.debug "$device.displayName couldn't parse $description"
		}
	}

    //def thermStatusS = "System ${device.currentValue('thermostatOperatingState')} | Fan ${device.currentValue('thermostatFanState')} | Battery ${device.currentValue('battery')}%"
    def thermStatusS = "Fan ${device.currentValue('thermostatFanState') != "idle" ? "On" : "Idle"} | ${device.currentValue('battery')}%"
    //log.trace thermStatusS
    sendEvent(name: "thermStatus", value: thermStatusS, displayed: false) // Return the status

    def fanStateS
    if (device.currentValue('thermostatFanMode') == "auto") {
        if (device.currentValue('thermostatFanState') != "idle") {
            fanStateS = "autoOn"
        } else {
            fanStateS = "autoOff"
        }
    } else {
        fanStateS = device.currentValue('thermostatFanMode')
    }
    //log.trace "Fan state: $fanStateS"
    sendEvent(name: "fanState", value: fanStateS)
	
    return result
}

// Event Generation
def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd) {
    log.trace "$cmd"

    def cmdScale = cmd.scale == 1 ? "F" : "C"
	def setpoint = getTempInLocalScale(cmd.scaledValue, cmdScale)
	def unit = getTemperatureScale()
	switch (cmd.setpointType) {
		case 1:
			sendEvent(name: "heatingSetpoint", value: setpoint, unit: unit, displayed: false)
			updateThermostatSetpoint("heatingSetpoint", setpoint)
			break;
		case 2:
			sendEvent(name: "coolingSetpoint", value: setpoint, unit: unit, displayed: false)
			updateThermostatSetpoint("coolingSetpoint", setpoint)
			break;
		default:
			log.debug "unknown setpointType $cmd.setpointType"
			return
	}
	// So we can respond with same format
	state.size = cmd.size
	state.scale = cmd.scale
	state.precision = cmd.precision
	// Make sure return value is not result from above expresion
	return 0
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv3.SensorMultilevelReport cmd) {
    log.trace "$cmd"

	def map = [:]
	if (cmd.sensorType == 1) {
        map.value = convertTemperatureIfNeeded(cmd.scaledSensorValue?.toBigDecimal(), cmd.scale == 1 ? "F" : "C")?.toDouble()?.round(cmd.precision ? 1 : 0) // Keep upto one decimal point for compatibility with newer thermostats with improved precision reporting
		map.unit = getTemperatureScale()
		map.name = "temperature"
		updateThermostatSetpoint(null, null)
	} else if (cmd.sensorType == 5) {
		map.value = cmd.scaledSensorValue
		map.unit = "%"
		map.name = "humidity"
	}
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatOperatingState"]
	switch (cmd.operatingState) {
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_IDLE:
			map.value = "idle"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_HEATING:
			map.value = "heating"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_COOLING:
			map.value = "cooling"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_FAN_ONLY:
			map.value = "fan only"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_HEAT:
			map.value = "pending heat"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_COOL:
			map.value = "pending cool"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_VENT_ECONOMIZER:
			map.value = "vent economizer"
			break
	}
	// Makes sure we have the correct thermostat mode
	sendHubCommand(new physicalgraph.device.HubAction(zwave.thermostatModeV2.thermostatModeGet().format()))
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanstatev1.ThermostatFanStateReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatFanState", unit: ""]
	switch (cmd.fanOperatingState) {
		case 0:
			map.value = "idle"
			break
		case 1:
			map.value = "running"
			break
		case 2:
			map.value = "running high"
			break
	}
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatMode", data:[supportedThermostatModes: state.supportedModes]]
	switch (cmd.mode) {
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_OFF:
			map.value = "off"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_HEAT:
			map.value = "heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUXILIARY_HEAT:
			map.value = "emergency heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_COOL:
			map.value = "cool"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUTO:
			map.value = "auto"
			break
	}
	sendEvent(map)
	updateThermostatSetpoint(null, null)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport cmd) {
    log.trace "$cmd"

	def map = [name: "thermostatFanMode", data:[supportedThermostatFanModes: state.supportedFanModes]]
	switch (cmd.fanMode) {
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_AUTO_LOW:
			map.value = "auto"
			break
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_LOW:
			map.value = "on"
			break
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_CIRCULATION:
			map.value = "circulate"
			break
	}
	sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd) {
    log.trace "$cmd"

	def supportedModes = []
	if(cmd.off) { supportedModes << "off" }
	if(cmd.heat) { supportedModes << "heat" }
	if(cmd.cool) { supportedModes << "cool" }
	if(cmd.auto) { supportedModes << "auto" }
	if(cmd.auxiliaryemergencyHeat) { supportedModes << "emergency heat" }

	state.supportedModes = supportedModes
	sendEvent(name: "supportedThermostatModes", value: supportedModes, displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeSupportedReport cmd) {
    log.trace "$cmd"

	def supportedFanModes = []
	if(cmd.auto) { supportedFanModes << "auto" }
	if(cmd.circulation) { supportedFanModes << "circulate" }
	if(cmd.low) { supportedFanModes << "on" }

	state.supportedFanModes = supportedFanModes
	sendEvent(name: "supportedThermostatFanModes", value: supportedFanModes, displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
    log.trace "$cmd"

	if (cmd.manufacturerName) {
		updateDataValue("manufacturer", cmd.manufacturerName)
	}
	if (cmd.productTypeId) {
		updateDataValue("productTypeId", cmd.productTypeId.toString())
	}
	if (cmd.productId) {
		updateDataValue("productId", cmd.productId.toString())
	}
    
    def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
    log.debug "msr: $msr"
    updateDataValue("MSR", msr)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd) {
	log.debug "Zwave BasicReport: $cmd"
}

def zwaveEvent(physicalgraph.zwave.commands.multichannelv3.MultiInstanceCmdEncap cmd) {
    def encapsulatedCommand = cmd?.encapsulatedCommand([0x31: 3]) // Encapsulate Sensor Multi Level (0x31) and use Version 3 of the class
    log.trace ("multichannelv3.MultiInstanceCmdEncap: command from instance ${cmd?.instance}: ${encapsulatedCommand}")
    if (encapsulatedCommand) {
        return zwaveEvent(encapsulatedCommand)
    } else {
        log.warn "multichannelv3.MultiInstanceCmdEncap: unrecognized command $cmd"
    }
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
    log.trace "$cmd"

    def map = [ name: "battery", unit: "%" ]
    if (cmd.batteryLevel == 0xFF || cmd.batteryLevel == 0) {
        map.value = 1
        map.descriptionText = "battery is low!"
    } else {
        map.value = cmd.batteryLevel
    }
    sendEvent(map)
}

def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
    log.trace "$cmd"

    def result = []
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	def text = "$device.displayName: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	result << createEvent(descriptionText: text, isStateChange: false)
    
    if (state.MSR?.startsWith("0098-") && (cmd.applicationVersion <= 8)) {
        text = "Found CT-XXX thermostat model with defective v${cmd.applicationVersion} firmware. Clock functionality may be impaired"
        state.defectiveClock = true
        log.warn text
        result << createEvent(descriptionText: text, displayed: true)
    } else {
        state.defectiveClock = false // Reset incase the user upgraded the Z-Wave module
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) {
    log.trace "$cmd"

    switch (state.MSR) {
        case "5254-0200-8031": // ZTS-110
        switch (cmd.parameterNumber) {
            case 1:
            log.trace "Current Temperature Swing: ${(cmd.configurationValue[0] & 0x7)}.0Â°F" // Max value is 4 in increments of 1.0Â°F (filter the rest out)
            sendEvent(name:"temperatureSwing", value:"${(cmd.configurationValue[0] & 0x7)}.0Â°F", displayed: true)
            break

            case 11:
            log.trace "Current Auto Temperature Change Report: ${cmd.configurationValue[0] & 0xF}.0Â°F" // Max value is 8 in increments of 1.0Â°F (filter the rest out)
            sendEvent(name:"temperatureChangeReport", value:"${cmd.configurationValue[0] & 0xF}.0Â°F", displayed: true)
            break

            case 13:
            log.trace "Current Temperature Calibration Correction: ${cmd.configurationValue[0] as byte}.0Â°F" // See docs
            sendEvent(name:"temperatureCalibration", value:"${cmd.configurationValue[0] as byte}.0Â°F", displayed: true)
            break

            default:
                break    
        }
        break

        case ~/0098-.*/: // CT-XXX
        switch (cmd.parameterNumber) {
            case 1:
            log.trace "Current Auto Temperature Change Report: ${(cmd.configurationValue[0] & 0x7) * 0.5}Â°F" // Max value is 4 in increments of 0.5Â°F (filter the rest out)
            sendEvent(name:"temperatureChangeReport", value:"${(cmd.configurationValue[0] & 0x7) * 0.5}Â°F", displayed: true)
            break

            case 7:
            log.trace "Current Temperature Swing: ${(cmd.configurationValue[0] & 0xF) * 0.5}Â°F" // Max value is 8 in increments of 0.5Â°F (filter the rest out)
            sendEvent(name:"temperatureSwing", value:"${(cmd.configurationValue[0] & 0xF) * 0.5}Â°F", displayed: true)
            break

            default:
                break    
        }
        break

        default:
            break
    }

    [] // Just info, nothing to do
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
    log.warn "Unexpected zwave command $cmd"
}

// Command Implementations
def configure() {
    log.trace "Configure called"

    // Identify and configure the thermostat
    log.trace "Device MSR: $state.MSR"
    checkThermostatModel()
    runIn(30, refresh) // Give it some time and then run refresh
    delayBetween([
        //discoverConfigParameters(), // DEBUGGING
        zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
        zwave.versionV1.versionGet().format(),
        setConfigParameters()
    ], 2300)
}

def refresh() {
    // Force a refresh
    log.info "Requested a refresh"
    state.lastBatteryGet = (new Date().time) - (1440 * 60000)
    state.lastClockSet = (new Date().time) - (1440 * 60000)
    state.lastPollGet = (new Date().time) - (30 * 60000)

    // Identify and configure the thermostat
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        delayBetween([
            zwave.manufacturerSpecificV2.manufacturerSpecificGet().format(),
            zwave.versionV1.versionGet().format(),
            poll()
        ], 2000)
    } else {
        checkThermostatModel()
        log.trace "Device MSR: $state.MSR"
        delayBetween([
            poll()
        ], 2000)
    }

    // NOTHING AFTER THIS AS THE ZWAVE NEEDS TO BE RETURNED TO BE EXECUTED
}

def poll() {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Z-Wave Thermostat with Temperature, Humidity and Auto Time Setting Device Handler"]) // Save DH Name for parent app

    def doPoll = false

    if (batterySaveMode) { // If we are in battery power save mode then we poll once it 30 minutes only
        log.debug "Battery save mode, fetching updates every 30 minutes"
        def nowTime = new Date().time
        def ageInMinutes = state.lastPollGet ? (nowTime - state.lastPollGet)/60000 : 30
        log.debug "Last poll ${ageInMinutes} minutes ago"
        if (ageInMinutes >= 30) {
            state.lastPollGet = nowTime
            log.info "Fetching fresh thermostate state"
            doPoll = true
        }
    } else {
        doPoll = true // no battery save, lets get the values
    }

    if (doPoll) {
        log.trace "Polling thermostat information"
        delayBetween([
            zwave.thermostatModeV2.thermostatModeSupportedGet().format(),
            zwave.thermostatFanModeV3.thermostatFanModeSupportedGet().format(),
            zwave.thermostatModeV2.thermostatModeGet().format(),
            zwave.thermostatFanModeV3.thermostatFanModeGet().format(),
            zwave.thermostatFanStateV1.thermostatFanStateGet().format(),
            zwave.sensorMultilevelV3.sensorMultilevelGet().format(), // current temperature
            zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format(),
            zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format(),
            zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2).format(),
            zwave.multiInstanceV1.multiInstanceCmdEncap(instance: 2).encapsulate(zwave.sensorMultilevelV3.sensorMultilevelGet()).format(), // CT-100/101 Customization - Humidity is an encapsulated multilevel sensor get command, 2nd instance
            getBattery(),
            setClock()
        ], 2300)
    }
    else {
        log.trace "Poll called again to soon, skipping poll to save battery"
        sendEvent(name: "battery", value: device.currentValue("battery"), unit: "%", descriptionText: "Battery save mode", displayed: false, isStateChange: true) // We need to send something otherwise Poll dies if nothing is done
    }
}

def levelUp() {
    log.trace "Level Up called"
    levelUpDown(1)
}

def levelDown() {
    log.trace "Level Down called"
    levelUpDown(-1)
}

def levelUpDown(value) {
    log.trace "levelUpDown called with value $value, current thermostat mode ${device.currentState("thermostatMode")?.value}"

    // NOTE: Bug in ST platform, for iOS devices we only get 0 (down) and 1 (up) for this control
    // For Android devices we get an absolute number showing the number of times up/down have been called since the page was opened (e.g. called up 4 times we get +4, if down then we get +3). If you open the page again and press up you get +1, if you close and open again and press down you get -1 (and the as long as the page is open it will be cumulative)

    // Determine which OS based on value behaviors (urrgghhh.....ST!)
    def upLevel
    if (!state.lastLevelUpDown)
    state.lastLevelUpDown = 0 // If it isn't defined lets baseline it

    if ((state.lastLevelUpDown == 1) && (value == 1)) // Last time it was 1 and again it's 1 its increase
    upLevel = true
    else if ((state.lastLevelUpDown == 0) && (value == 0)) // Last time it was 0 and again it's 0 then it's decrease
        upLevel = false
    else if ((state.lastLevelUpDown == -1) && (value == -1)) // Last time it was -1 and again it's -1 then it's decrease
        upLevel = false
    else if ((value - state.lastLevelUpDown) > 0) // If it's increasing then it's up
        upLevel = true
    else if ((value - state.lastLevelUpDown) < 0) // If it's decreasing then it's down
        upLevel = false
    else
        log.error "UNDEFINED STATE, CONTACT DEVELOPER. Last level $state.lastLevelUpDown, Current level, $value"

    state.lastLevelUpDown = value // Save it

    if (upLevel) { // Increase the current temperature (check heating or cooling mode)
        log.debug "Increasing temperature by 1Â°"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([raiseHeatingSetpoint(), raiseCoolSetpoint()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            raiseHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            raiseCoolSetpoint()
        }
    } else {
        log.debug "Reducing temperature by 1Â°"
        if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
            delayBetween([lowerHeatingSetpoint(), lowerCoolSetpoint()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
            lowerHeatingSetpoint()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
            lowerCoolSetpoint()
        }
    }

    // NOTHING AFTER THE COMMANDS OR THE COMMANDS WONT WORK
}

def raiseHeatingSetpoint() {
    log.debug "Setting heat set point up"
	alterSetpoint(true, "heatingSetpoint")
}

def lowerHeatingSetpoint() {
    log.debug "Setting heat set point down"
	alterSetpoint(false, "heatingSetpoint")
}

def raiseCoolSetpoint() {
    log.debug "Setting cool set point up"
	alterSetpoint(true, "coolingSetpoint")
}

def lowerCoolSetpoint() {
    log.debug "Setting cool set point down"
	alterSetpoint(false, "coolingSetpoint")
}

// Adjusts nextHeatingSetpoint either .5Â° C/1Â° F) if raise true/false
def alterSetpoint(raise, setpoint) {
	def locationScale = getTemperatureScale()
	def deviceScale = (state.scale == 1) ? "F" : "C"
	def heatingSetpoint = getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = getTempInLocalScale("coolingSetpoint")
	def targetValue = (setpoint == "heatingSetpoint") ? heatingSetpoint : coolingSetpoint
	def delta = (locationScale == "F") ? 1 : 0.5
	targetValue += raise ? delta : - delta

	def data = enforceSetpointLimits(setpoint, [targetValue: targetValue, heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
	// update UI without waiting for the device to respond, this to give user a smoother UI experience
	// also, as runIn's have to overwrite and user can change heating/cooling setpoint separately separate runIn's have to be used
	if (data.targetHeatingSetpoint) {
		sendEvent("name": "heatingSetpoint", "value": getTempInLocalScale(data.targetHeatingSetpoint, deviceScale),
				unit: getTemperatureScale(), eventType: "ENTITY_UPDATE", displayed: false)
	}
	if (data.targetCoolingSetpoint) {
		sendEvent("name": "coolingSetpoint", "value": getTempInLocalScale(data.targetCoolingSetpoint, deviceScale),
				unit: getTemperatureScale(), eventType: "ENTITY_UPDATE", displayed: false)
	}
	if (data.targetHeatingSetpoint && data.targetCoolingSetpoint) {
		runIn(5, "updateHeatingSetpoint", [data: data, overwrite: true])
	} else if (setpoint == "heatingSetpoint" && data.targetHeatingSetpoint) {
		runIn(5, "updateHeatingSetpoint", [data: data, overwrite: true])
	} else if (setpoint == "coolingSetpoint" && data.targetCoolingSetpoint) {
		runIn(5, "updateCoolingSetpoint", [data: data, overwrite: true])
	}
}

def updateHeatingSetpoint(data) {
	updateSetpoints(data)
}

def updateCoolingSetpoint(data) {
	updateSetpoints(data)
}

def enforceSetpointLimits(setpoint, data) {
	def locationScale = getTemperatureScale() 
	def minSetpoint = (setpoint == "heatingSetpoint") ? getTempInDeviceScale(40, "F") : getTempInDeviceScale(50, "F")
	def maxSetpoint = (setpoint == "heatingSetpoint") ? getTempInDeviceScale(90, "F") : getTempInDeviceScale(99, "F")
	def deadband = (state.scale == 1) ? 3 : 2  // 3Â°F, 2Â°C
	def targetValue = getTempInDeviceScale(data.targetValue, locationScale)
	def heatingSetpoint = null
	def coolingSetpoint = null
	// Enforce min/mix for setpoints
	if (targetValue > maxSetpoint) {
		targetValue = maxSetpoint
	} else if (targetValue < minSetpoint) {
		targetValue = minSetpoint
	}
	// Enforce 3 degrees F deadband between setpoints
	if (setpoint == "heatingSetpoint") {
		heatingSetpoint = targetValue 
		coolingSetpoint = (heatingSetpoint + deadband > getTempInDeviceScale(data.coolingSetpoint, locationScale)) ? heatingSetpoint + deadband : null
	}
	if (setpoint == "coolingSetpoint") {
		coolingSetpoint = targetValue
		heatingSetpoint = (coolingSetpoint - deadband < getTempInDeviceScale(data.heatingSetpoint, locationScale)) ? coolingSetpoint - deadband : null
	}
	return [targetHeatingSetpoint: heatingSetpoint, targetCoolingSetpoint: coolingSetpoint]
}

def setHeatingSetpoint(degrees) {
	if (degrees) {
		state.heatingSetpoint = degrees.toDouble()
		runIn(2, "updateSetpoints", [overwrite: true])
	}
}

def setCoolingSetpoint(degrees) {
	if (degrees) {
		state.coolingSetpoint = degrees.toDouble()
		runIn(2, "updateSetpoints", [overwrite: true])
	}
}

def updateSetpoints() {
	def deviceScale = (state.scale == 1) ? "F" : "C"
	def data = [targetHeatingSetpoint: null, targetCoolingSetpoint: null]
	def heatingSetpoint = getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = getTempInLocalScale("coolingSetpoint")
	if (state.heatingSetpoint) {
		data = enforceSetpointLimits("heatingSetpoint", [targetValue: state.heatingSetpoint,
				heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
	}
	if (state.coolingSetpoint) {
		heatingSetpoint = data.targetHeatingSetpoint ? getTempInLocalScale(data.targetHeatingSetpoint, deviceScale) : heatingSetpoint
		coolingSetpoint = data.targetCoolingSetpoint ? getTempInLocalScale(data.targetCoolingSetpoint, deviceScale) : coolingSetpoint
		data = enforceSetpointLimits("coolingSetpoint", [targetValue: state.coolingSetpoint,
				heatingSetpoint: heatingSetpoint, coolingSetpoint: coolingSetpoint])
		data.targetHeatingSetpoint = data.targetHeatingSetpoint ?: heatingSetpoint
	}
	state.heatingSetpoint = null
	state.coolingSetpoint = null
	updateSetpoints(data)
}

def updateSetpoints(data) {
	def cmds = []
	if (data.targetHeatingSetpoint) {
		cmds << new physicalgraph.device.HubAction(zwave.thermostatSetpointV1.thermostatSetpointSet(
					setpointType: 1, scale: state.scale, precision: state.precision, scaledValue: data.targetHeatingSetpoint).format())
	}
	if (data.targetCoolingSetpoint) {
		cmds << new physicalgraph.device.HubAction(zwave.thermostatSetpointV1.thermostatSetpointSet(
					setpointType: 2, scale: state.scale, precision: state.precision, scaledValue: data.targetCoolingSetpoint).format())
	}
    cmds << new physicalgraph.device.HubAction(zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format())
    cmds << new physicalgraph.device.HubAction(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format()) // Bug CT-XX doesn't report change in thermostat operating state

	sendHubCommand(cmds)
}

// thermostatSetpoint is not displayed by any tile as it can't be predictable calculated due to
// the device's quirkiness but it is defined by the capability so it must be set, set it to the most likely value
def updateThermostatSetpoint(setpoint, value) {
	def scale = getTemperatureScale()
	def heatingSetpoint = (setpoint == "heatingSetpoint") ? value : getTempInLocalScale("heatingSetpoint")
	def coolingSetpoint = (setpoint == "coolingSetpoint") ? value : getTempInLocalScale("coolingSetpoint")
	def mode = device.currentValue("thermostatMode")
	def thermostatSetpoint = heatingSetpoint    // corresponds to (mode == "heat" || mode == "emergency heat")
	if (mode == "cool") {
		thermostatSetpoint = coolingSetpoint
	} else if (mode == "auto" || mode == "off") {
		// Set thermostatSetpoint to the setpoint closest to the current temperature
		def currentTemperature = getTempInLocalScale("temperature")
		if (currentTemperature > (heatingSetpoint + coolingSetpoint)/2) {
			thermostatSetpoint = coolingSetpoint
		}
	}
	sendEvent(name: "thermostatSetpoint", value: thermostatSetpoint, unit: getTemperatureScale())
}

def switchMode() {
	def currentMode = device.currentValue("thermostatMode")
	def supportedModes = state.supportedModes
	// Old version of supportedModes was as string, make sure it gets updated
	if (supportedModes && supportedModes.size() && supportedModes[0].size() > 1) {
		def next = { supportedModes[supportedModes.indexOf(it) + 1] ?: supportedModes[0] }
		def nextMode = next(currentMode)
		runIn(2, "setGetThermostatMode", [data: [nextMode: nextMode], overwrite: true])
	} else {
		log.warn "supportedModes not defined"
		getSupportedModes()
	}
}

def switchToMode(nextMode) {
	def supportedModes = state.supportedModes
	// Old version of supportedModes was as string, make sure it gets updated
	if (supportedModes && supportedModes.size() && supportedModes[0].size() > 1) {
		if (supportedModes.contains(nextMode)) {
			runIn(2, "setGetThermostatMode", [data: [nextMode: nextMode], overwrite: true])
		} else {
			log.debug("ThermostatMode $nextMode is not supported by ${device.displayName}")
		}
	} else {
		log.warn "supportedModes not defined"
		getSupportedModes()
	}
}

def getSupportedModes() {
	def cmds = []
	cmds << new physicalgraph.device.HubAction(zwave.thermostatModeV2.thermostatModeSupportedGet().format())
	sendHubCommand(cmds)
}

def switchFanMode() {
	def currentMode = device.currentValue("thermostatFanMode")
	def supportedFanModes = state.supportedFanModes
	// Old version of supportedFanModes was as string, make sure it gets updated
	if (supportedFanModes && supportedFanModes.size() && supportedFanModes[0].size() > 1) {
		def next = { supportedFanModes[supportedFanModes.indexOf(it) + 1] ?: supportedFanModes[0] }
		def nextMode = next(currentMode)
		runIn(2, "setGetThermostatFanMode", [data: [nextMode: nextMode], overwrite: true])
	} else {
		log.warn "supportedFanModes not defined"
		getSupportedFanModes()
	}
}

def switchToFanMode(nextMode) {
	def supportedFanModes = state.supportedFanModes
	// Old version of supportedFanModes was as string, make sure it gets updated
	if (supportedFanModes && supportedFanModes.size() && supportedFanModes[0].size() > 1) {
		if (supportedFanModes.contains(nextMode)) {
			runIn(2, "setGetThermostatFanMode", [data: [nextMode: nextMode], overwrite: true])
		} else {
			log.debug("FanMode $nextMode is not supported by ${device.displayName}")
		}
	} else {
		log.warn "supportedFanModes not defined"
		getSupportedFanModes()
	}
}

def getSupportedFanModes() {
	def cmds = [new physicalgraph.device.HubAction(zwave.thermostatFanModeV3.thermostatFanModeSupportedGet().format())]
	sendHubCommand(cmds)
}

def getModeMap() { [
	"off": 0,
	"heat": 1,
	"cool": 2,
	"auto": 3,
	"emergency heat": 4
]}

def setThermostatMode(String value) {
	switchToMode(value)
}

def setGetThermostatMode(data) {
	def cmds = [new physicalgraph.device.HubAction(zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[data.nextMode]).format()),
			new physicalgraph.device.HubAction(zwave.thermostatModeV2.thermostatModeGet().format()),
            new physicalgraph.device.HubAction(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format())] // Get Operating mode, thermostat doesn't always report it
	sendHubCommand(cmds)
}

def getFanModeMap() { [
	"auto": 0,
	"on": 1,
	"circulate": 6
]}

def setThermostatFanMode(String value) {
	switchToFanMode(value)
}

def setGetThermostatFanMode(data) {
	def cmds = [new physicalgraph.device.HubAction(zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: fanModeMap[data.nextMode]).format()),
			new physicalgraph.device.HubAction(zwave.thermostatFanModeV3.thermostatFanModeGet().format()),
            new physicalgraph.device.HubAction(zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format())] // Get Operating mode, thermostat doesn't always report it
	sendHubCommand(cmds)
}

def off() {
	switchToMode("off")
}

def heat() {
	switchToMode("heat")
}

def emergencyHeat() {
	switchToMode("emergency heat")
}

def cool() {
	switchToMode("cool")
}

def auto() {
	switchToMode("auto")
}

def fanOn() {
	switchToFanMode("on")
}

def fanAuto() {
	switchToFanMode("auto")
}

def fanCirculate() {
	switchToFanMode("circulate")
}

// Get stored temperature from currentState in current local scale
def getTempInLocalScale(state) {
	def temp = device.currentState(state)
	if (temp && temp.value && temp.unit) {
		return getTempInLocalScale(temp.value.toBigDecimal(), temp.unit)
	}
	return 0
}

// get/convert temperature to current local scale
def getTempInLocalScale(temp, scale) {
	if (temp && scale) {
		def scaledTemp = convertTemperatureIfNeeded(temp.toBigDecimal(), scale).toDouble()
		return (getTemperatureScale() == "F" ? scaledTemp.round(0).toInteger() : roundC(scaledTemp))
	}
	return 0
}

def getTempInDeviceScale(state) {
	def temp = device.currentState(state)
	if (temp && temp.value && temp.unit) {
		return getTempInDeviceScale(temp.value.toBigDecimal(), temp.unit)
	}
	return 0
}

def getTempInDeviceScale(temp, scale) {
	if (temp && scale) {
		def deviceScale = (state.scale == 1) ? "F" : "C"
		return (deviceScale == scale) ? temp :
				(deviceScale == "F" ? celsiusToFahrenheit(temp).toDouble().round(0).toInteger() : roundC(fahrenheitToCelsius(temp)))
	}
	return 0
}

def roundC (tempC) {
	return (Math.round(tempC.toDouble() * 2))/2
}

private checkThermostatModel() {
    switch (state.MSR) {
        case "008B-5452-5433": // Trane Z-Wave Thermostat
            log.debug "Found Trane Z-Wave Thermostat"
            sendEvent(name:"thermostatModel", value:"Trane", displayed: true)
            break

        case "5254-0200-8031": // ZTS-110
            log.debug "Found ZTS-110 Thermostat"
            sendEvent(name:"thermostatModel", value:"ZTS-110", displayed: true)
            break

        case "0098-6401-0107": //CT-100
        case "0098-6401-0106": //CT-100 Vivint
            log.debug "Found CT-100 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-100", displayed: true)
            break

        case "0098-6501-000C": //CT-101 (lowe's model)
            log.debug "Found CT-101 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-101", displayed: true)
            break

        case "0098-1E10-0158": //CT-30
        case "0098-1E12-015C": //CT-30e
        case "0098-0000-0000": //CT-30 (local alarm company model)
        case "0098-1E12-015E": //CT-30 Rev C1
        case "0098-0001-001E": //CT-30 APX
        case "0098-0001-0000": //CT-30 Amazon Brown Box
        case "0098-0001-00FF": //CT-30 Amazon Brown Box
            log.debug "Found CT-30 Thermostat"
            sendEvent(name:"thermostatModel", value:"CT-30", displayed: true)
            break

        default:
            log.debug "Unknown thermostat with MSR $state.MSR"
            sendEvent(name:"thermostatModel", value:"Unknown thermostat with MSR $state.MSR", displayed: true)
            break
    }
}

private getBattery() {	//once every 24 hours
    def nowTime = new Date().time
    def ageInMinutes = state.lastBatteryGet ? (nowTime - state.lastBatteryGet)/60000 : 1440
    log.debug "Battery report age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
        state.lastBatteryGet = nowTime
        log.debug "Fetching fresh battery value"
        zwave.batteryV1.batteryGet().format()
    } else "delay 87"
}

private setClock() {	// once a day
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        log.error "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately"
        sendEvent(name: "InvalidTimezone", value: "InvalidTimezone", descriptionText: "Hub timeZone not set, using ${timeZone.getDisplayName()} timezone. Please set Hub location and timezone for the codes to work accurately", isStateChange: true, displayed: true)
    }

    def nowTime = new Date().time
    def ageInMinutes = state.lastClockSet ? (nowTime - state.lastClockSet)/60000 : 1440
    log.debug "Clock set age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
        state.lastClockSet = nowTime
        def nowCal = Calendar.getInstance(timeZone) // get current location timezone
        if (state.defectiveClock) {
            log.warn "Found CT-XXX with defective firmware, setting clock in day into the past"
            nowCal.add(Calendar.DAY_OF_MONTH, -1) // the thermostat with defective firmware shows it one day into the future to send one day in the past to get correct day
        }
        log.debug "Setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", timeZone)}"
        sendEvent(name: "SetClock", value: "setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", timeZone)}", displayed: true)
        zwave.clockV1.clockSet(hour: nowCal.get(Calendar.HOUR_OF_DAY), minute: nowCal.get(Calendar.MINUTE), weekday: nowCal.get(Calendar.DAY_OF_WEEK)).format()
    } else "delay 87"
}

def setConfigParameters() {
    def cmds = []
    switch (state.MSR) {
        case "5254-0200-8031": // ZTS-110
        if (settings.autoTempDiffZTS) {
            log.debug "Setting new value of Auto Temp Change Report to $settings.autoTempDiffZTS"
            def paramValue
            switch (settings.autoTempDiffZTS) {
                case "Disabled":
                paramValue = 0
                break
                case "1.0Â°F":
                paramValue = 1
                break
                case "2.0Â°F":
                paramValue = 2
                break
                case "3.0Â°F":
                paramValue = 3
                break
                case "4.0Â°F":
                paramValue = 4
                break
                case "5.0Â°F":
                paramValue = 5
                break
                case "6.0Â°F":
                paramValue = 6
                break
                case "7.0Â°F":
                paramValue = 7
                break
                case "8.0Â°F":
                paramValue = 8
                break
                default:
                    paramValue = 4 // Default 4.0Â°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 11).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 11, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 11).format() // Verify after
        }

        if (settings.tempCalibrationZTS) {
            log.debug "Setting new value of Temperature Calibration to $settings.tempCalibrationZTS"
            def paramValue
            switch (settings.tempCalibrationZTS) {
                case "-10Â°F":
                paramValue = 0xF6
                break
                case "-9Â°F":
                paramValue = 0xF7
                break
                case "-8Â°F":
                paramValue = 0xF8
                break
                case "-7Â°F":
                paramValue = 0xF9
                break
                case "-6Â°F":
                paramValue = 0xFA
                break
                case "-5Â°F":
                paramValue = 0xFB
                break
                case "-4Â°F":
                paramValue = 0xFC
                break
                case "-3Â°F":
                paramValue = 0xFD
                break
                case "-2Â°F":
                paramValue = 0xFE
                break
                case "-1Â°F":
                paramValue = 0xFF
                break
                case "0Â°F":
                paramValue = 0
                break
                case "1Â°F":
                paramValue = 0x01
                break
                case "2Â°F":
                paramValue = 0x02
                break
                case "3Â°F":
                paramValue = 0x03
                break
                case "4Â°F":
                paramValue = 0x04
                break
                case "5Â°F":
                paramValue = 0x05
                break
                case "6Â°F":
                paramValue = 0x06
                break
                case "7Â°F":
                paramValue = 0x07
                break
                case "8Â°F":
                paramValue = 0x08
                break
                case "9Â°F":
                paramValue = 0x09
                break
                case "10Â°F":
                paramValue = 0x0A
                break
                default:
                    paramValue = 0 // Default 0Â°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 13).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 13, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 13).format() // Verify after
        }

        if (settings.swingZTS) {
            log.debug "Setting new value of Temp Swing to $settings.swingZTS"
            def paramValue
            switch (settings.swingZTS) {
                case "1.0Â°F":
                paramValue = 1
                break
                case "2.0Â°F":
                paramValue = 2
                break
                case "3.0Â°F":
                paramValue = 3
                break
                case "4.0Â°F":
                paramValue = 4
                break
                default:
                    paramValue = 2 // Default 2.0Â°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 1, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Verify after
        }
        break

        case ~/0098-.*/: // CT-XXX
        if (settings.autoTempDiffCT) {
            log.debug "Setting new value of Auto Temp Differential Report to $settings.autoTempDiffCT"
            def paramValue
            switch (settings.autoTempDiffCT) {
                case "Disabled":
                paramValue = 0
                break
                case "0.5Â°F":
                paramValue = 1
                break
                case "1.0Â°F":
                paramValue = 2
                break
                case "1.5Â°F":
                paramValue = 3
                break
                case "2.0Â°F":
                paramValue = 4
                break
                default:
                    paramValue = 2 // Default 1.0Â°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 1, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 1).format() // Verify after
        }

        if (settings.swingCT) {
            log.debug "Setting new value of Temp Swing to $settings.swingCT"
            def paramValue
            switch (settings.swingCT) {
                case "0.5Â°F":
                paramValue = 1
                break
                case "1.0Â°F":
                paramValue = 2
                break
                case "1.5Â°F":
                paramValue = 3
                break
                case "2.0Â°F":
                paramValue = 4
                break
                case "2.5Â°F":
                paramValue = 5
                break
                case "3.0Â°F":
                paramValue = 6
                break
                case "3.5Â°F":
                paramValue = 7
                break
                case "4.0Â°F":
                paramValue = 8
                break
                default:
                    paramValue = 2 // Default 1.0Â°F
                break
            }

            cmds << zwave.configurationV2.configurationGet(parameterNumber: 7).format() // Check before
            cmds << zwave.configurationV2.configurationSet(parameterNumber: 7, size: 1, configurationValue: [paramValue]).format()
            cmds << zwave.configurationV2.configurationGet(parameterNumber: 7).format() // Verify after
        }
        break

        default:
            break
    }

    if (cmds) {
        delayBetween(cmds, 2000)
    } else {
        null
    }
}

def discoverConfigParameters() {
    log.trace "Discovering the first 15 configuration parameters"

    def cmds = []
    (1..15).each { param ->
        cmds << zwave.configurationV2.configurationGet(parameterNumber: param).format() // Check before
    }
    delayBetween(cmds, 2000)
}

// Legacy for backward compatibility
def quickSetCool(degrees) {
    setCoolingSetpoint(degrees)
}

def quickSetHeat(degrees) {
    setHeatingSetpoint(degrees)
}